# 基础概念

---

### 标记、指令、命令

- 标记（符号、Symbol）

  在汇编中标记指的是标记内存位置的一个标识符，常见在`data`段的变量命名或者以`标记:`命名形式出现。它的主要作用是用来标识一个内存位置，供程序员识别。

- 指令（操作码助记符）

  指令也称操作码助记符，主要作用是将操作码转换成让程序员易于辨识的英文单词，在编译器编译的过程中，操作码助记符最后也会转换回操作码。如：`push %ebp` == `55`。

- 命令

  命令是编译器内部的功能，不同的编译器可识别的功能不一。如`.section .data`，则表示向编译器声明这是一个变量声明段，该段下面的语句都是用来声明变量的。`.section`的参数是段类型，`.data`是它的参数。命令格式均为`.命令`。

### 数据段

- `.data`：数据段，在这个段中定义的任何数据元素都保留在内存中并且可以被汇编语言程序中的指令读取和写入。**该段中的数据信息会被记录在可执行文件中**（影响可执行文件的大小），原因是data段的数据是被认为已被初始化的，因此初始数据需要在记录在可执行文件中，当载入内存的时候初始化变量。
- `.rodata`：只读数据段，在这个段中定义的任何数据元素都保留在内存中并且只能读取，不能修改。**该段中的数据信息会被记录在可执行文件中**（影响可执行文件的大小）。
- `.bss`：缓冲区，在这个段中定义的数据无须声明数据类型，只需要声明需要保留的内存大小即可。该段中的数据信息**不**会被记录在可执行文件中。

### EFLAGS寄存器

`eflags`寄存器的作用是存储运算指令执行后的各种标志，在`gdb`调试的时候可以使用`p $eflags`指令查看产生的标志

| 标志 | 名称                   | 产生条件                                                     |
| ---- | ---------------------- | ------------------------------------------------------------ |
| CF   | 进位（Carry）标志      | 无符号数溢出标志；(最高位有无进位) 异或 (执行加法还是减法)；有进位代表1，执行减法代表1 |
| OF   | 溢出（Overflow）标志   | 有符号数溢出标志；对于有符号数，(最高位有无进位) 异或 (次高位有无进位)；有进位代表1 |
| PF   | 奇偶校验（Parity）标志 |                                                              |
| SF   | 符号（Sign）标志       | 指出结果为正还是负                                           |
| ZF   | 零（Zero）标志         | 操作结果是否为零                                             |



### 指令语句

- `mov`

  1. 解析：

     赋值指令，格式：`mov? 值, 目标位置`

  2. 例子：

     | mov? | bits | example           |
     | ---- | ---- | ----------------- |
     | b    | 8    | `movb %al, %bl`   |
     | w    | 16   | `movw %ax, %bx`   |
     | l    | 32   | `movl %eax, %ebx` |
     | q    | 64   | `movq %rax, %rbx` |

  3. 扩展：
     1. 当指令中含有寄存器时，`mov?`中的`?`可不写，如：`mov $0xFF00EE88 %eax`
     2. 当使用`as`作为编译器的时候，所有内存地址都是32位的，可使用`movl`记录内存地址

- `$`

  1. 解析：

     1. 立即数的标识，格式：`$立即数`
     2. 取内存地址，格式：`$内存变量名`

  2. 例子：

     |             | value | immediate |
     | ----------- | ----- | --------- |
     | decimal     | 125   | $125      |
     | hexadecimal | f8    | $0xf8     |
     | octal       | 17    | $017      |
     | binary      | 1001  | $0b1001   |

- `add`

  1. 解析：

     将两个数相加

  2. 例子：

     | add? | bits | example           |
     | ---- | ---- | ----------------- |
     | b    | 8    | `addb %al, %bl`   |
     | w    | 16   | `addw %ax, %bx`   |
     | l    | 32   | `addl %eax, %ebx` |

- `sub`

  1. 解析：

     将两个数相减

  2. 例子：

     | sub? | bits | example           |
     | ---- | ---- | ----------------- |
     | b    | 8    | `subb %al, %bl`   |
     | w    | 16   | `subw %ax, %bx`   |
     | l    | 32   | `subl %eax, %ebx` |

  3. 无符号整数使用 `mul`，有符号整数使用 `imul`

- `mul`

  1. 解析：

     将两个数相乘

  2. 例子：

     | sub? | bits | example           |
     | ---- | ---- | ----------------- |
     | b    | 8    | `subb %al, %bl`   |
     | w    | 16   | `subw %ax, %bx`   |
     | l    | 32   | `subl %eax, %ebx` |

- `div`

  1. 解析：

     将两个数相除

  2. 例子：

     | sub? | bits | example           |
     | ---- | ---- | ----------------- |
     | b    | 8    | `subb %al, %bl`   |
     | w    | 16   | `subw %ax, %bx`   |
     | l    | 32   | `subl %eax, %ebx` |

  3. 无符号整数使用 `div`，有符号整数使用 `idiv`

- `sal`|`shl`

  1. 解析：左移
  2. 例子：

     | sal? | bits | example         |
     | ---- | ---- | --------------- |
     | b    | 8    | `salb $2, %bl`  |
     | w    | 16   | `salw $2, %bx`  |
     | l    | 32   | `sall $2, %ebx` |

- `shr`

  1. 解析：逻辑右移，移位后最高位永远补0

- `sar`

  1. 解析：算术右移，移位后最高位是什么就补什么（假设是有符号数字，那么最高位代表正负数，因此算术右移最高位不能改变，即正负数不能改变）

- `rcl`

  1. 解析：循环左移

- `rcr`

  1. 解析：循环右移

### 内存操作

```assembly
.seciton .data
values:
	.int 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60
```

- 间接寻址操作：

  | instruction          | action                                                       | result                 |
  | -------------------- | ------------------------------------------------------------ | ---------------------- |
  | `movl values, %eax`  | 将`values`的第一个整型移到`eax`寄存器                        | `eax=10`               |
  | `movl $values, %edi` | 将`values`的地址移到`edi`寄存器，相当于C语言里的`&p`操作     | `edi=values的起始地址` |
  | `movl %ebx, (%edi)`  | 将`ebx`寄存器的值赋值给`edi`指向的内存地址，相当于C语言中的`*p=a` | `10`替换成`ebx`的值    |
  | `movl $99, 4(%edi)`  | 将立即数`99`赋值给`edi`指向的内存地址再偏移4个byte的内存地址，数字4可为负数 | `15`替换成`99`         |

- 直接寻址：

  格式：`base_address(offset_address, index, size)`

  解析：`memory_address = base_address + offset_address + index * size` 

  ```assembly
  movl $4, %eax
  movl $2, %edi
  movl values(, %edi, 4), %ebx
  ```

  结果：`ebx = 25`

  注意：

  - `offset_address`必须为寄存器
  - `index`必须为寄存器
  - `size`可以为数字
  - 等于`0`的位置可以省略不写

### 编译32位程序

`as --32 -o 输出文件 目标文件`

`ld -m elf_i386 -I /lib/ld-linux.so.2 对象文件 -l动态库名称`

### 函数调用

- Windows：在 64位 以前，参数是把所有参数**从右到左**依次压栈。在 64 位后，Windows 下是依次使用 `rcx`、`rdx`、`r8`、`r9`这四个寄存器传递**从左到右**四个参数，如果参数大于 4 个，再**从右到左**依次压栈。

- Linux：在 64位 以前，参数是把所有参数**从右到左**依次压栈。在 64 位后分以下两种情况：

  - 对于普通调用是把前 6 个参数，依次用`rdi`、`rsi`、`rdx`、**rcx**、`r8`、`r9`。
  - 对于系统调用是把前 6 个参数，依次用 `rdi`、`rsi`、`rdx`、**r10**、`r8`、`r9`。

  然后剩下的参数**从右到左**依次压栈。