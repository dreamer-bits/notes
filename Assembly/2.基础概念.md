# 基础概念

---

### 标记、指令、命令

- 标记（符号、Symbol）

  在汇编中标记指的是标记内存位置的一个标识符，常见在`data`段的变量命名或者以`标记:`命名形式出现。它的主要作用是用来标识一个内存位置，供程序员识别。

- 指令（操作码助记符）

  指令也称操作码助记符，主要作用是将操作码转换成让程序员易于辨识的英文单词，在编译器编译的过程中，操作码助记符最后也会转换回操作码。如：`push %ebp` == `55`。

- 命令

  命令是编译器内部的功能，不同的编译器可识别的功能不一。如`.section .data`，则表示向编译器声明这是一个变量声明段，该段下面的语句都是用来声明变量的。`.section`的参数是段类型，`.data`是它的参数。命令格式均为`.命令`。

### 数据段

- `.data`：数据段，在这个段中定义的任何数据元素都保留在内存中并且可以被汇编语言程序中的指令读取和写入。**该段中的数据信息会被记录在可执行文件中**（影响可执行文件的大小），原因是data段的数据是被认为已被初始化的，因此初始数据需要在记录在可执行文件中，当载入内存的时候初始化变量。如：

  ```assembly
  .section .data
    output:
      .asciz "The processor Vendor ID is '%s'\n"
  ```

  - 数据段还能主要用于定义变量数据，但是也可以在这声明静态数据符号，如：

    ```assembly
    .section .data
       .equ LINUX_SYS_CALL, 0x80
    .section .text
       movl $LINUX_SYS_CALL, %eax
    ```

- `.rodata`：只读数据段，在这个段中定义的任何数据元素都保留在内存中并且只能读取，不能修改。**该段中的数据信息会被记录在可执行文件中**（影响可执行文件的大小）。

  ```assembly
  .section .rodata
    output:
      .asciz "The processor Vendor ID is '%s'\n"
  ```

- `.bss`：缓冲区，在这个段中定义的数据无须声明数据类型，只需要声明需要保留的内存大小即可。该段中的数据信息**不**会被记录在可执行文件中。如：

  ```assembly
  .section .bbs
      .lcomm buffer, 12
  ```

### DATA段数据类型

|        命令         |           数据类型           |
| :-----------------: | :--------------------------: |
|     .ascii <值>     |          文本字符串          |
|     .asciz <值>     |   以空字符结尾的文本字符串   |
|     .byte <值>      |            字节值            |
|    .double <值>     |         双精度浮点数         |
|     .float <值>     |         单精度浮点数         |
|      .int <值>      |    32位整数（和.int相同）    |
|     .long <值>      |           64位整数           |
|     .octa <值>      |          16字节整数          |
|     .quad <值>      |          8字节整数           |
|     .short <值>     |           16位整数           |
|    .single <值>     | 单精度浮点数（和.float相同） |
|    .fill <长度>     |    填充长度字节的数据元素    |
| .equ <标签名>, <值> |       声明静态数据符号       |



### EFLAGS寄存器

`eflags`寄存器的作用是存储运算指令执行后的各种标志，在`gdb`调试的时候可以使用`p $eflags`指令查看产生的标志

| 标志 | 名称                   | 产生条件                                                     |
| ---- | ---------------------- | ------------------------------------------------------------ |
| CF   | 进位（Carry）标志      | 无符号数溢出标志；(最高位有无进位) 异或 (执行加法还是减法)；有进位代表1，执行减法代表1；进位判断时需要将减法转换加法 |
| OF   | 溢出（Overflow）标志   | 有符号数溢出标志；对于有符号数，(最高位有无进位) 异或 (次高位有无进位)；有进位代表1 |
| PF   | 奇偶校验（Parity）标志 |                                                              |
| SF   | 符号（Sign）标志       | 指出结果为正还是负                                           |
| ZF   | 零（Zero）标志         | 操作结果是否为零                                             |

### 内存操作

```assembly
.seciton .data
values:
	.int 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60
```

- 间接寻址操作：

  | instruction          | action                                                       | result                 |
  | -------------------- | ------------------------------------------------------------ | ---------------------- |
  | `movl values, %eax`  | 将`values`的第一个整型移到`eax`寄存器                        | `eax=10`               |
  | `movl $values, %edi` | 将`values`的地址移到`edi`寄存器，相当于C语言里的`&p`操作     | `edi=values的起始地址` |
  | `movl %ebx, (%edi)`  | 将`ebx`寄存器的值赋值给`edi`指向的内存地址，相当于C语言中的`*p=a` | `10`替换成`ebx`的值    |
  | `movl $99, 4(%edi)`  | 将立即数`99`赋值给`edi`指向的内存地址再偏移4个byte的内存地址，数字4可为负数 | `15`替换成`99`         |

- 直接寻址：

  格式：`base_address(offset_address, index, size)`

  解析：`memory_address = base_address + offset_address + index * size` 

  ```assembly
  movl $4, %eax
  movl $2, %edi
  movl values(, %edi, 4), %ebx
  ```

  结果：`ebx = 25`

  注意：

  - `offset_address`必须为寄存器
  - `index`必须为寄存器
  - `size`可以为数字
  - 等于`0`的位置可以省略不写

### 编译32位程序

`as --32 -o 输出文件 目标文件`

`ld -m elf_i386 -I /lib/ld-linux.so.2 对象文件 -l动态库名称`

### 函数调用

- Windows：在 64位 以前，参数是把所有参数**从右到左**依次压栈。在 64 位后，Windows 下是依次使用 `rcx`、`rdx`、`r8`、`r9`这四个寄存器传递**从左到右**四个参数，如果参数大于 4 个，再**从右到左**依次压栈。

- Linux：在 64位 以前，参数是把所有参数**从右到左**依次压栈。在 64 位后分以下两种情况：

  - 对于普通调用是把前 6 个参数，依次用`rdi`、`rsi`、`rdx`、**rcx**、`r8`、`r9`。
  - 对于系统调用是把前 6 个参数，依次用 `rdi`、`rsi`、`rdx`、**r10**、`r8`、`r9`。

  然后剩下的参数**从右到左**依次压栈。